// negative inversion error
ASSERT_E(mah_invert_chord(&CHORD(
    4, 0,
    NOTE_L(NOTE(E, 1, MAH_OCTAVE_1), NOTE(G, -1, MAH_OCTAVE_1), NOTE(B, 0, MAH_OCTAVE_1), NOTE(D, 1, MAH_OCTAVE_2)),
    NOTE_L(NOTE(E, 1, MAH_OCTAVE_1), NOTE(G, -1, MAH_OCTAVE_1), NOTE(B, 0, MAH_OCTAVE_1), NOTE(D, 1, MAH_OCTAVE_2))
), -1, &ERR), ERROR_INVALID_INVERSION);

// too high inversion error
ASSERT_E(mah_invert_chord(&CHORD(
    2, 0,
    NOTE_L(NOTE(A, 2, MAH_OCTAVE_1), NOTE(G, 2, MAH_OCTAVE_1)),
    NOTE_L(NOTE(A, 2, MAH_OCTAVE_1), NOTE(G, 2, MAH_OCTAVE_1))
), 3, &ERR), ERROR_INVALID_INVERSION);

// root inversion
ASSERT_CP(mah_invert_chord(&CHORD, 0, &ERR), CHORD(
    3, 0,
    NOTE_L(NOTE(D, 3, MAH_OCTAVE_1), NOTE(F, 1, MAH_OCTAVE_1), NOTE(A, 2, MAH_OCTAVE_1)),
    NOTE_L(NOTE(D, 3, MAH_OCTAVE_1), NOTE(F, 1, MAH_OCTAVE_1), NOTE(A, 2, MAH_OCTAVE_1))
), CHORD(
    3, 0,
    NOTE_L(NOTE(D, 3, MAH_OCTAVE_1), NOTE(F, 1, MAH_OCTAVE_1), NOTE(A, 2, MAH_OCTAVE_1)),
    NOTE_L(NOTE(D, 3, MAH_OCTAVE_1), NOTE(F, 1, MAH_OCTAVE_1), NOTE(A, 2, MAH_OCTAVE_1))
));

// 2nd inversion
ASSERT_CP(mah_invert_chord(&CHORD, 2, &ERR), CHORD(
    3, 0,
    NOTE_L(NOTE(B, -1, MAH_OCTAVE_2), NOTE(D, 1, MAH_OCTAVE_2), NOTE(G, 3, MAH_OCTAVE_3)),
    NOTE_L(NOTE(B, -1, MAH_OCTAVE_2), NOTE(D, 1, MAH_OCTAVE_2), NOTE(G, 3, MAH_OCTAVE_3))
), CHORD(
    3, 2,
    NOTE_L(NOTE(B, -1, MAH_OCTAVE_2), NOTE(D, 1, MAH_OCTAVE_2), NOTE(G, 3, MAH_OCTAVE_3)),
    NOTE_L(NOTE(G, 3, MAH_OCTAVE_3), NOTE(B, -1, MAH_OCTAVE_3), NOTE(D, 1, MAH_OCTAVE_3))
));

// resetting to root inversion
ASSERT_CP(mah_invert_chord(&CHORD, 0, &ERR), CHORD(
    3, 1,
    NOTE_L(NOTE(A, -1, MAH_OCTAVE_0), NOTE(C, 1, MAH_OCTAVE_1), NOTE(E, 3, MAH_OCTAVE_1)),
    NOTE_L(NOTE(C, 1, MAH_OCTAVE_1), NOTE(E, 3, MAH_OCTAVE_1), NOTE(A, -1, MAH_OCTAVE_1))
), CHORD(
    3, 0,
    NOTE_L(NOTE(A, -1, MAH_OCTAVE_0), NOTE(C, 1, MAH_OCTAVE_1), NOTE(E, 3, MAH_OCTAVE_1)),
    NOTE_L(NOTE(A, -1, MAH_OCTAVE_0), NOTE(C, 1, MAH_OCTAVE_1), NOTE(E, 3, MAH_OCTAVE_1))
));