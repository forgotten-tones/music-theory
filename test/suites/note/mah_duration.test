// Basic duration tests //

// Test basic duration enum values (1920 ticks = whole note)
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(C, 0, 4, MAH_WHOLE, NULL), &ERR), 1920);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(D, 0, 4, MAH_HALF, NULL), &ERR), 960);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(E, 0, 4, MAH_QUARTER, NULL), &ERR), 480);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(F, 0, 4, MAH_EIGHTH, NULL), &ERR), 240);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(G, 0, 4, MAH_SIXTEENTH, NULL), &ERR), 120);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(A, 0, 4, MAH_THIRTYSECOND, NULL), &ERR), 60);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(B, 0, 4, MAH_SIXTYFOURTH, NULL), &ERR), 30);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(C, 0, 5, MAH_ONETWENTYEIGHTH, NULL), &ERR), 15);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Test dotted notes (dotted = 1.5x base duration)
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(F, 0, 4, MAH_DOTTED_WHOLE, NULL), &ERR), 2880);  // 1920 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(G, 0, 4, MAH_DOTTED_HALF, NULL), &ERR), 1440);   // 960 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(A, 0, 4, MAH_DOTTED_QUARTER, NULL), &ERR), 720);  // 480 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(B, 0, 4, MAH_DOTTED_EIGHTH, NULL), &ERR), 360);   // 240 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(C, 0, 5, MAH_DOTTED_SIXTEENTH, NULL), &ERR), 180); // 120 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(D, 0, 5, MAH_DOTTED_THIRTYSECOND, NULL), &ERR), 90); // 60 * 1.5
ASSERT_D(ERR, MAH_ERROR_NONE);

// Tuplet tests //

// Triplet: 3 notes in time of 2 quarters = 480 * 2 / 3 = 320 ticks each
struct mah_tuplet triplet = mah_create_tuplet(3, 2, MAH_QUARTER, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(A, 0, 4, MAH_TUPLET, &triplet), &ERR), 320);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Quintuplet: 5 notes in time of 4 quarters = 480 * 4 / 5 = 384 ticks each  
struct mah_tuplet quintuplet = mah_create_tuplet(5, 4, MAH_QUARTER, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(B, 0, 4, MAH_TUPLET, &quintuplet), &ERR), 384);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Septuplet: 7 notes in time of 4 quarters = 480 * 4 / 7 = ~274 ticks each
struct mah_tuplet septuplet = mah_create_tuplet(7, 4, MAH_QUARTER, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(C, 0, 5, MAH_TUPLET, &septuplet), &ERR), 274); // 1920/7 = ~274
ASSERT_D(ERR, MAH_ERROR_NONE);

// Eighth note triplet: 3 eighths in time of 2 eighths = 240 * 2 / 3 = 160 ticks each
struct mah_tuplet eighth_triplet = mah_create_tuplet(3, 2, MAH_EIGHTH, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(D, 0, 5, MAH_TUPLET, &eighth_triplet), &ERR), 160);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Time signature validation tests //

// 4/4 time: should accept 4 quarter notes
struct mah_time_sig common_time = TIME_SIG(4, 4);
struct mah_timed_note measure_44[] = {
    TIMED_NOTE(C, 0, 4, MAH_QUARTER, NULL),
    TIMED_NOTE(D, 0, 4, MAH_QUARTER, NULL),
    TIMED_NOTE(E, 0, 4, MAH_QUARTER, NULL),
    TIMED_NOTE(F, 0, 4, MAH_QUARTER, NULL)
};
mah_validate_measure(measure_44, 4, common_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// 3/4 time: should reject 4 quarter notes (too long)
struct mah_time_sig waltz_time = TIME_SIG(3, 4);
ASSERT_E(mah_validate_measure(measure_44, 4, waltz_time, &ERR), ERROR_INVALID_MEASURE_DURATION);

// 3/4 time: should accept 3 quarter notes
struct mah_timed_note measure_34[] = {
    TIMED_NOTE(G, 0, 4, MAH_QUARTER, NULL),
    TIMED_NOTE(A, 0, 4, MAH_QUARTER, NULL),
    TIMED_NOTE(B, 0, 4, MAH_QUARTER, NULL)
};
mah_validate_measure(measure_34, 3, waltz_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Complex example: dotted half + quarter in 4/4 (3 beats + 1 beat = 4 beats)
struct mah_timed_note complex_measure[] = {
    TIMED_NOTE(G, 0, 4, MAH_DOTTED_HALF, NULL),  // 3 beats (1440 ticks)
    TIMED_NOTE(A, 0, 4, MAH_QUARTER, NULL)       // 1 beat (480 ticks)
};
mah_validate_measure(complex_measure, 2, common_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// 6/8 time: 6 eighth notes
struct mah_time_sig six_eight = TIME_SIG(6, 8);
struct mah_timed_note measure_68[] = {
    TIMED_NOTE(C, 0, 4, MAH_EIGHTH, NULL),
    TIMED_NOTE(D, 0, 4, MAH_EIGHTH, NULL),
    TIMED_NOTE(E, 0, 4, MAH_EIGHTH, NULL),
    TIMED_NOTE(F, 0, 4, MAH_EIGHTH, NULL),
    TIMED_NOTE(G, 0, 4, MAH_EIGHTH, NULL),
    TIMED_NOTE(A, 0, 4, MAH_EIGHTH, NULL)
};
mah_validate_measure(measure_68, 6, six_eight, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// 2/2 time: 2 half notes (cut time)
struct mah_time_sig cut_time = TIME_SIG(2, 2);
struct mah_timed_note measure_22[] = {
    TIMED_NOTE(C, 0, 4, MAH_HALF, NULL),
    TIMED_NOTE(F, 0, 4, MAH_HALF, NULL)
};
mah_validate_measure(measure_22, 2, cut_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Rest tests //

// Test rest creation and duration
struct mah_timed_note quarter_rest = REST(MAH_QUARTER);
ASSERT_D(quarter_rest.tone_timed, MAH_REST);
ASSERT_D(quarter_rest.acci_timed, 0);
ASSERT_D(quarter_rest.pitch_timed, 0);
ASSERT_D(quarter_rest.duration, MAH_QUARTER);
ASSERT_D(mah_get_duration_ticks(&REST(MAH_HALF), &ERR), 960);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Measure with rests
struct mah_timed_note measure_with_rests[] = {
    TIMED_NOTE(C, 0, 4, MAH_QUARTER, NULL),
    REST(MAH_QUARTER),
    TIMED_NOTE(D, 0, 4, MAH_QUARTER, NULL),
    REST(MAH_QUARTER)
};
mah_validate_measure(measure_with_rests, 4, common_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);

// Duration comparison tests //

// Test duration comparison
struct mah_timed_note whole_note = TIMED_NOTE(C, 0, 4, MAH_WHOLE, NULL);
struct mah_timed_note half_note = TIMED_NOTE(D, 0, 4, MAH_HALF, NULL);
struct mah_timed_note quarter_note = TIMED_NOTE(E, 0, 4, MAH_QUARTER, NULL);

ASSERT_D(mah_compare_durations(&whole_note, &half_note, &ERR), 1);    // whole > half
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_compare_durations(&half_note, &whole_note, &ERR), -1);   // half < whole  
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_compare_durations(&quarter_note, &quarter_note, &ERR), 0); // quarter == quarter
ASSERT_D(ERR, MAH_ERROR_NONE);

// Compare dotted and regular notes
struct mah_timed_note dotted_quarter = TIMED_NOTE(F, 0, 4, MAH_DOTTED_QUARTER, NULL);
struct mah_timed_note eighth_plus_sixteenth = TIMED_NOTE(G, 0, 4, MAH_EIGHTH, NULL); // Just for comparison reference

ASSERT_D(mah_compare_durations(&dotted_quarter, &quarter_note, &ERR), 1); // dotted quarter > quarter
ASSERT_D(ERR, MAH_ERROR_NONE);

// Error handling tests //

// Invalid tuplet ratios
ASSERT_E(mah_create_tuplet(0, 2, MAH_QUARTER, &ERR), ERROR_INVALID_TUPLET);
ASSERT_E(mah_create_tuplet(3, 0, MAH_QUARTER, &ERR), ERROR_INVALID_TUPLET);
ASSERT_E(mah_create_tuplet(-1, 2, MAH_QUARTER, &ERR), ERROR_INVALID_TUPLET);

// Invalid tuplet base (can't use MAH_TUPLET as base)
ASSERT_E(mah_create_tuplet(3, 2, MAH_TUPLET, &ERR), ERROR_INVALID_TUPLET);

// Invalid time signatures
struct mah_timed_note test_measure[] = {TIMED_NOTE(C, 0, 4, MAH_QUARTER, NULL)};
ASSERT_E(mah_validate_measure(test_measure, 1, TIME_SIG(0, 4), &ERR), ERROR_INVALID_TIME_SIG);
ASSERT_E(mah_validate_measure(test_measure, 1, TIME_SIG(4, 0), &ERR), ERROR_INVALID_TIME_SIG);
ASSERT_E(mah_validate_measure(test_measure, 1, TIME_SIG(-1, 4), &ERR), ERROR_INVALID_TIME_SIG);

// Invalid measure parameters
ASSERT_E(mah_validate_measure(NULL, 1, common_time, &ERR), ERROR_INVALID_MEASURE_DURATION);
ASSERT_E(mah_validate_measure(test_measure, 0, common_time, &ERR), ERROR_INVALID_MEASURE_DURATION);
ASSERT_E(mah_validate_measure(test_measure, -1, common_time, &ERR), ERROR_INVALID_MEASURE_DURATION);

// Test with invalid tuplet in measure validation
struct mah_tuplet invalid_tuplet = {0, 2, MAH_QUARTER}; // Invalid n=0
struct mah_timed_note invalid_tuplet_note = TIMED_NOTE(C, 0, 4, MAH_TUPLET, &invalid_tuplet);
struct mah_timed_note measure_with_invalid_tuplet[] = {invalid_tuplet_note};
ASSERT_E(mah_validate_measure(measure_with_invalid_tuplet, 1, common_time, &ERR), ERROR_INVALID_TUPLET);

// Fraction tests //

// Test getting duration fractions
int num, den;
mah_get_duration_fraction(&TIMED_NOTE(C, 0, 4, MAH_WHOLE, NULL), &num, &den, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(num, 1);
ASSERT_D(den, 1);

mah_get_duration_fraction(&TIMED_NOTE(D, 0, 4, MAH_HALF, NULL), &num, &den, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(num, 1);
ASSERT_D(den, 2);

mah_get_duration_fraction(&TIMED_NOTE(E, 0, 4, MAH_DOTTED_QUARTER, NULL), &num, &den, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(num, 3);
ASSERT_D(den, 8);

// Test triplet fraction: 3 notes in 2 quarters = (1/4 * 2) / 3 = 2/12 = 1/6
mah_get_duration_fraction(&TIMED_NOTE(F, 0, 4, MAH_TUPLET, &triplet), &num, &den, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(num, 1);
ASSERT_D(den, 6);

// Complex tuplets and combinations tests //

// Duplet: 2 notes in time of 3 (unusual but valid)
struct mah_tuplet duplet = mah_create_tuplet(2, 3, MAH_QUARTER, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);
ASSERT_D(mah_get_duration_ticks(&TIMED_NOTE(G, 0, 4, MAH_TUPLET, &duplet), &ERR), 720); // 480 * 3 / 2
ASSERT_D(ERR, MAH_ERROR_NONE);

// Mix of regular notes and tuplets in a measure
struct mah_timed_note mixed_measure[] = {
    TIMED_NOTE(C, 0, 4, MAH_QUARTER, NULL),          // 480 ticks
    TIMED_NOTE(D, 0, 4, MAH_TUPLET, &triplet),       // 320 ticks  
    TIMED_NOTE(E, 0, 4, MAH_TUPLET, &triplet),       // 320 ticks
    TIMED_NOTE(F, 0, 4, MAH_TUPLET, &triplet),       // 320 ticks
    TIMED_NOTE(G, 0, 4, MAH_QUARTER, NULL)           // 480 ticks
    // Total: 480 + 320*3 + 480 = 1920 ticks = 1 whole note = 4/4 measure
};
mah_validate_measure(mixed_measure, 5, common_time, &ERR);
ASSERT_D(ERR, MAH_ERROR_NONE);